/*
Tristan Lucero (R11597605) | Assignment #4 | 10/27/2020
This program uses and lexical analyzer previous built to develop a parser for the following code. This is a recursive descent syntax paser in C.

P ::= S
S ::= V:=E | read(V) | write(V) | while C do S od | S;S
C ::= E < E | E > E | E = E | E <> E | E <= E | E >= E
E ::= T | E + T | E - T
T ::= F | T * F | T / F
F ::= (E) | N | V
V ::= a | b | … | y | z | aV | bV | … | yV | zV
N ::= 0 | 1 | … | 8 | 9 | 0N | 1N | … | 8N | 9N

This file is the parser code for that project.
*/
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include "parser.h"
#include "front.h"


//initalize global variables
static void error();
int errorTrue = 0;
int errorToken;
char errorLexeme [100];
extern char lexeme [100];

//variable for sCode being used, boolean value
int sCodeUsed = 0;
//variable for if last token was semicolon, boolean value
int lastSemi = 0;


/*Function Prototypes*/
void sCode();
void cCode();
void cCode();
void expr();
void term();
void factor();
static void error();

/**
 * This is the example Recursive-Descent Parser in pp. 181 - 185 in the
 * textbook
 *
 * Sebesta, R. W. (2012). Concepts of Programming Languages.
 * Pearson, 10th edition.
 *
 *
 * */

//P ::= S
//parses p code
void pCode()
{
    printf("Enter P\n");
    sCode();
    printf("Exit P\n");
}

//S ::= V:=E | read(V) | write(V) | while C do S od | S;S
//parses s code
void sCode()
{
    printf("Enter S\n");
    if(nextToken == IDENT && sCodeUsed == 0){
        printf("-----IDENT-----\n");
        lex();
        if (nextToken == ASSIGN_OP){
            lex();
            expr();
        }
        else{
            error();
        }
        sCodeUsed = 1;
    }
    else if(nextToken == KEY_READ || nextToken == KEY_WRITE && sCodeUsed == 0){
        printf("-----READ OR WRITE-----\n");
        lex();
        if(nextToken == LEFT_PAREN){
            lex();
            if(nextToken == IDENT){
                lex();
                if(nextToken == RIGHT_PAREN){
                    lex();
                }
                else{
                    error();
                }
            }
            else{
                error();
            }
        }
        else{
            error();
        }
        sCodeUsed = 1;
    }
    else if(nextToken == KEY_WHILE && sCodeUsed == 0){
        printf("-----WHILE-----\n");
        lex();
        cCode();
        if(nextToken == KEY_DO){
            printf("-----KEY DO-----\n");
            lex();
            sCode();
        }
        else
            error();
        sCodeUsed = 1;
    }


    if(nextToken == KEY_OD){
        printf("-----KEY_OD2-----\n");
        sCodeUsed = 0;
        lex();
    }
    //printf("------sCodeUsed = %d", sCodeUsed);
    else if(nextToken == SEMICOLON){
        printf("-----SEMICOLON-----\n");
        sCodeUsed = 0;
        lex();
        if(nextToken == KEY_OD)
            error();
        if(nextToken == EOF){
            lastSemi = 1;
            printf("----------------------------------------\n");
            error();
        }
        sCode();
    }
    else if (sCodeUsed == 1)
        error();
    printf("Exit S\n");
}

//C ::= E < E | E > E | E = E | E <> E | E <= E | E >= E
//parses c code
void cCode()
{
    printf("Enter C\n");
    expr();

    if (nextToken == LESSER_OP || nextToken == GREATER_OP
           || nextToken == EQUAL_OP || nextToken == NEQUAL_OP || nextToken == LEQUAL_OP
           || nextToken == GEQUAL_OP) {
        lex();
        expr();
    }

    printf("Exit C\n");
}



/* expr
 * Parses strings in the language generated by the rule:
 * <expr> -> <term> {(+ | -) <term>}

 <expr> → <expr> + <term>
        | <expr> - <term>
        | <term>

 E ::= T | E + T | E - T

 E ::= TE'
 E' ::= +TE` || -TE` || e
 */
void expr()
{
    printf("Enter <expr>\n");

    /* Parse the first term */
    term();

    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP) {
        lex();
        term();
    }

    printf("Exit <expr>\n");
} /* End of function expr */


/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | /) <factor>)
 */
void term()
{
    printf("Enter <term>\n");
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP) {
            lex();
            factor();
    }
    printf("Exit <term>\n");
} /* End of function term */



/* factor
 * Parses strings in the language generated by the rule:
 * <factor> -> id | int_constant | ( <expr> )
 * */
 //F ::= (E) | N | V
void factor()
{
    printf("Enter <factor>\n");
    /* Determine which RHS */

    if (nextToken == IDENT || nextToken == INT_LIT){
        lex(); /* Get the next token */
    }
    //if next token equals one of these tokens, don't do anything
    else if (nextToken == KEY_READ || nextToken == KEY_WRITE
            || nextToken == KEY_WHILE || nextToken == KEY_DO
            || nextToken == KEY_OD){
    }
    else {
        /* If the RHS is (<expr>), call lex to pass over the
        left parenthesis, call expr, and check for the right
        parenthesis */
        if (nextToken == LEFT_PAREN) {
            lex();
            expr();

            if (nextToken == RIGHT_PAREN) {
                lex();
            } else {
                error();
            }
        } /* End of if (nextToken == ... */

        /* It was not an id, an integer literal, or a left parenthesis */
        else
        {
            error();
        }
    } /* End of else */
    printf("Exit <factor>\n");;
} /* End of function factor */

/*
prints error message, and sets errorTrue to 1 then exists program with error code
*/
static void error()
{
    //if lexeme is not EOF or if lexeme is EOF and last character was semicolon
    if(strcmp(lexeme, "EOF") != 0 || strcmp(lexeme, "EOF") == 0 && lastSemi == 1){
        printf("Error encounter: The next lexeme was %s and the next token was %s\n", lexeme, numToToken(nextToken));
        errorTrue = 1;
        exit(1);
    }
}
